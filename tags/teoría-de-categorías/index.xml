<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>teoría de categorías on El Baúl del programador</title>
        <link>https://elbauldelprogramador.com/tags/teor%C3%ADa-de-categor%C3%ADas/</link>
        <description>Recent content in teoría de categorías on El Baúl del programador</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>es-ES</language>
        <lastBuildDate>Mon, 13 Nov 2017 10:02:16 +0100</lastBuildDate>
        <image>
            <url>https://elbauldelprogramador.com/img/bio-photo-rss.png</url>
            <link>https://elbauldelprogramador.com/tags/teor%C3%ADa-de-categor%C3%ADas/</link>
            <title>teoría de categorías on El Baúl del programador</title>
            <width>144</width>
            <height>144</height>
        </image>
        <atom:link href="https://elbauldelprogramador.com/tags/teor%C3%ADa-de-categor%C3%ADas/" rel="self" type="application/rss+xml" />
        
        <item>
            <title>Teoría de Categorías en Scala - Tipos y funciones</title>
            <link>https://elbauldelprogramador.com/teoria-categorias-scala-tipos-funciones/</link>
            <pubDate>Mon, 13 Nov 2017 10:02:16 +0100</pubDate>
            
            <guid>https://elbauldelprogramador.com/teoria-categorias-scala-tipos-funciones/</guid>
            <description>&lt;p&gt;

&lt;blockquote&gt;
&lt;p&gt;Este artículo forma parte de una serie sobre Teoría de Categorías en Scala que estoy escribiendo basándome en &lt;a target=&#34;_blank&#34; href=&#34;https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/&#34;&gt;el libro de Bartosz Milewski&lt;/a&gt;. Conforme voy leyendo, tomo notas y intento resolver los ejercicios propuestos por Bartosz, pero en Scala. El producto de ese trabajo son estos artículos que comparto en este blog. Todo el código está en &lt;a href=&#34;https://github.com/elbaulp/Scala-Category-Theory&#34;&gt;elbaulp/Scala-Category-Theory&lt;/a&gt;, también puedes visitar la &lt;a href=&#34;https://elbauldelprogramador.com/scala-category-theory/&#34;&gt;tabla de contenidos&lt;/a&gt; de esta serie.&lt;/p&gt;
&lt;/blockquote&gt;



&lt;/p&gt;
&lt;p&gt;
&lt;em&gt;En el artículo anterior escribí sobre&lt;/em&gt; &lt;a href=&#34;https://elbauldelprogramador.com/teoria-categorias-scala-composicion/&#34;&gt;composición en Teoría de Categorías&lt;/a&gt;, &lt;em&gt;hoy voy a hablar sobre &lt;strong&gt;tipos y funciones en Teoría de Categorías.&lt;/strong&gt;&lt;/em&gt;
&lt;/p&gt;
&lt;h2 id=&#34;headline-1&#34;&gt;
Tipos y Funciones
&lt;/h2&gt;
&lt;p&gt;
Se pueden componer flechas, pero &lt;em&gt;no cualquier par de flechas&lt;/em&gt;, el destino de una flecha debe coincidir con el origen de la otra. En términos de programación: &lt;strong&gt;El tipo de retorno de una función debe coincidir con el tipo de entrada de la siguiente función.&lt;/strong&gt;
&lt;/p&gt;
&lt;h2 id=&#34;headline-2&#34;&gt;
¿Qué son los tipos?
&lt;/h2&gt;
&lt;p&gt;
Puedes pensar en un &lt;strong&gt;Tipo&lt;/strong&gt; como &lt;strong&gt;Conjuntos&lt;/strong&gt;, estos pueden ser &lt;em&gt;finitos&lt;/em&gt; (Booleanos, Chars) o &lt;em&gt;infinitos&lt;/em&gt; (Cadenas de texto, Enteros). En teoría de categorías existe una &lt;a href=&#34;https://es.wikipedia.org/wiki/Categor%C3%ADa_de_conjuntos&#34;&gt;Categoría de Conjuntos&lt;/a&gt;, llamada &lt;strong&gt;Set&lt;/strong&gt; (Conjunto). En esta categoría, los objetos son &lt;strong&gt;conjuntos&lt;/strong&gt;, y las flechas &lt;strong&gt;funciones de un conjunto a otro.&lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
La definición de arriba es en &lt;em&gt;el mundo matemático&lt;/em&gt;, en la realidad puedes pensar en los &lt;strong&gt;conjuntos como tipos&lt;/strong&gt; en un lenguaje de programación y en las &lt;strong&gt;funciones en el Set como funciones&lt;/strong&gt; en dicho lenguaje de programación. Pero hay un problema, en matemáticas una función simplemente &lt;em&gt;sabe la respuesta,&lt;/em&gt; pero en un lenguaje de programación eres tú quien debe implementar el código que calcule esa respuesta, y hay algunas funciones que nunca retornan. Como solución, muchos lenguajes de programación tienen un tipo llamado &lt;strong&gt;Tipo de fondo&lt;/strong&gt; (&lt;a href=&#34;https://en.wikipedia.org/wiki/Bottom_type&#34;&gt;Bottom type&lt;/a&gt;), todos los tipos extienden de él. En Haskell este tipo se denota por &lt;code class=&#34;verbatim&#34;&gt;_|_&lt;/code&gt;, en &lt;a href=&#34;https://elbauldelprogramador.com/tags/scala/&#34;&gt;scala&lt;/a&gt; por &lt;code class=&#34;verbatim&#34;&gt;Nothing&lt;/code&gt; (Puedes &lt;a href=&#34;http://www.scala-lang.org/api/current/scala/Nothing.html&#34;&gt;ver la documentación de este tipo&lt;/a&gt;). Una función que devuelve el tipo fondo se llama &lt;strong&gt;Función Parcial&lt;/strong&gt;.
&lt;/p&gt;
&lt;p&gt;
&amp;lt;!–ad–&amp;gt;
&lt;/p&gt;
&lt;h2 id=&#34;headline-3&#34;&gt;
El modelo matemático
&lt;/h2&gt;
&lt;p&gt;
Si eres desarrollador, estoy seguro que como muchos, te has encontrado ejecutando un intérprete en tu cabeza, mientras depurabas algún programa. El ser humano no es muy bueno en esta tarea, ya que es muy complicado llevar cuenta de todas las variables. Existen alternativas para saber si un programa es correcto, la &lt;a href=&#34;https://es.wikipedia.org/wiki/Sem%C3%A1ntica_formal&#34;&gt;Semática Formal&lt;/a&gt;. En resumen, la &lt;strong&gt;Semántica Formal&lt;/strong&gt; es un método para formalizar el &lt;em&gt;significado&lt;/em&gt; de un lenguaje de programación, se ocupa de encontrar objetos matemáticos (llamados dominio) que representan lo que hace el programa.
&lt;/p&gt;
&lt;p&gt;
Por contra a la &lt;em&gt;Semántica Formal&lt;/em&gt; está la &lt;a href=&#34;https://es.wikipedia.org/wiki/Sem%C3%A1ntica_operacional&#34;&gt;Semántica Operacional&lt;/a&gt;. Esta intenta demostrar ciertas propiedades de un programa (como su corrección), para ello construye demostraciones lógicas, aunque a menudo es complejo.
&lt;/p&gt;
&lt;p&gt;
Teniendo un modelo matemático (&lt;em&gt;Semántica Formal&lt;/em&gt;) es posible escribir demostraciones formales que verifiquen la corrección de un programa.
&lt;/p&gt;
&lt;h2 id=&#34;headline-4&#34;&gt;
Funciones Puras e Impuras
&lt;/h2&gt;
&lt;p&gt;
Las &lt;em&gt;funciones puras&lt;/em&gt; son aquellas que devuelven siempre el mismo resultado para la misma entrada, sin efectos colaterales. Las funciones matemáticas son un buen ejemplo de funciones puras. Por el contrario, las &lt;em&gt;funciones impuras&lt;/em&gt; tienen efectos colaterales.
&lt;/p&gt;
&lt;h2 id=&#34;headline-5&#34;&gt;
Ejemplos de Tipos
&lt;/h2&gt;
&lt;p&gt;
Al fin hemos llegado al asunto de este artículo, &lt;strong&gt;los tipos&lt;/strong&gt;.
&lt;/p&gt;
&lt;p&gt;
Voy a empezar desde abajo, es decir, con el &lt;strong&gt;Conjunto Vacío.&lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
¿Qué tipo definiría al &lt;a href=&#34;https://es.wikipedia.org/wiki/Conjunto_vac%C3%ADo&#34;&gt;Conjunto Vacío&lt;/a&gt;? Piensa un momento, lo mencioné un poco más arriba. En Haskell este tipo es &lt;code class=&#34;verbatim&#34;&gt;Void&lt;/code&gt;, en Scala &lt;code class=&#34;verbatim&#34;&gt;Nothing&lt;/code&gt;. Este conjunto no tiene ningún elemento. Anteriormente dije que hay una categoría llamada &lt;em&gt;Set&lt;/em&gt;, en la que los &lt;em&gt;objetos son conjuntos&lt;/em&gt; y las &lt;em&gt;flechas son funciones.&lt;/em&gt; En este contexto, si &lt;code class=&#34;verbatim&#34;&gt;A&lt;/code&gt; es un conjunto (El conjunto vacío), solo hay una función &lt;code class=&#34;verbatim&#34;&gt;f&lt;/code&gt; de &lt;code class=&#34;verbatim&#34;&gt;{}&lt;/code&gt; a &lt;code class=&#34;verbatim&#34;&gt;A&lt;/code&gt;, la &lt;a href=&#34;https://en.wikipedia.org/wiki/Function_(mathematics)#Empty_function&#34;&gt;Función Vacía&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;
¿Podrías definir una función que tome como parámetro un objeto de tipo &lt;code class=&#34;verbatim&#34;&gt;Void&lt;/code&gt; (&lt;em&gt;un conjunto vacío&lt;/em&gt;)? sí, pero no podrías llamarla, ya que no puedes pasarle un parámetro de tipo &lt;code class=&#34;verbatim&#34;&gt;Void&lt;/code&gt;. Sin embargo, el tipo de retorno de esta función podría ser de cualquier tipo. Este tipo de funciones (las que devuelven cualquier tipo) se llaman &lt;strong&gt;polimórficas en el tipo de retorno&lt;/strong&gt;, ejemplos:
&lt;/p&gt;
&lt;div class=&#34;src src-haskell&#34;&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-haskell&#34; data-lang=&#34;haskell&#34;&gt;&lt;span class=&#34;nf&#34;&gt;noPuedesLlamarme&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;::&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;Void&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
Una letra en minúscula en la declaración de una función en Haskell significa que &lt;code class=&#34;verbatim&#34;&gt;a&lt;/code&gt; puede ser de cualquier tipo. En Scala:
&lt;/p&gt;
&lt;div class=&#34;src src-scala&#34;&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-scala&#34; data-lang=&#34;scala&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;noPuedesLlamarme&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;Nothing&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;noPuedesLlamarme&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;Nothing&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;str&amp;#34;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
¿Cual sería el tipo asociado al &lt;strong&gt;&lt;a href=&#34;https://es.wikipedia.org/wiki/Conjunto_unitario&#34;&gt;Conjunto Unitario&lt;/a&gt;&lt;/strong&gt;? es decir, un conjunto de un solo elemento (Un posible valor). En C++ ese tipo es &lt;code class=&#34;verbatim&#34;&gt;void&lt;/code&gt; (No lo confundas con el &lt;code class=&#34;verbatim&#34;&gt;Void&lt;/code&gt; de Haskell, que representa el conjunto vacío). &lt;code class=&#34;verbatim&#34;&gt;void&lt;/code&gt; en C++ es un conjunto unitario, ya que tiene un único elemento. De hecho, puedes llamar a funciones que reciben &lt;code class=&#34;verbatim&#34;&gt;void&lt;/code&gt; como argumento. Ejemplos de estas funciones son &lt;code class=&#34;verbatim&#34;&gt;int f314() { ret 314 }&lt;/code&gt;, si la llamas, siempre devolverá 314. Aunque parezca no estar recibiendo ningún argumento, no es así. Si no pudieras pasarle argumento alguno no podrías llamarla. Por tanto, toma como argumento un valor ficticio con una única instancia (El conjunto Unitario, en este caso 314). El mismo ejemplo en Haskell y Scala:
&lt;/p&gt;
&lt;div class=&#34;src src-haskell&#34;&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-haskell&#34; data-lang=&#34;haskell&#34;&gt;&lt;span class=&#34;nf&#34;&gt;f314&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;::&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;Integer&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;-- De Unit a Integer&lt;/span&gt;
&lt;span class=&#34;nf&#34;&gt;f314&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;314&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
Aquí es más evidente que &lt;code class=&#34;verbatim&#34;&gt;f314&lt;/code&gt; toma un parámetro, el tipo &lt;code class=&#34;verbatim&#34;&gt;Unit&lt;/code&gt; (El cual permite un solo valor). Puedes llamar a esta función con &lt;code class=&#34;verbatim&#34;&gt;f314()&lt;/code&gt;, lo cual denota más explícitamente que toma un solo parámetro.
&lt;/p&gt;
&lt;p&gt;
En Scala, el tipo representando el &lt;strong&gt;Conjunto Unitario&lt;/strong&gt; también se llama &lt;a href=&#34;http://www.scala-lang.org/api/current/scala/Unit.html&#34;&gt;Unit&lt;/a&gt;, su único valor se denota con &lt;code class=&#34;verbatim&#34;&gt;()&lt;/code&gt;, como en Haskell:
&lt;/p&gt;
&lt;div class=&#34;src src-scala&#34;&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-scala&#34; data-lang=&#34;scala&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f314&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;314&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/* de () =&amp;gt; Int */&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
Aunque todo esto te parezca un sin sentido, o absurdo, el objetivo es construir los conceptos de abajo a arriba. Conforme profundices más en Teoría de Categorías, todo irá ganando sentido. Por ejemplo, con el conocimiento adquirido hasta el momento puedes evitar mencionar explícitamente elementos en un conjunto, ahora simplemente los referencias con flechas (Funciones en este caso, ya que estamos tratando con la categoría Set). Las funciones que van de &lt;strong&gt;Unit a cualquier tipo A&lt;/strong&gt; están en correspondencia una-a-una con los elementos de dicho conjunto A.
&lt;/p&gt;
&lt;p&gt;
¿Qué pasa con las funciones que &lt;strong&gt;devuelven &lt;code class=&#34;verbatim&#34;&gt;void&lt;/code&gt; (en C++) o &lt;code class=&#34;verbatim&#34;&gt;Unit&lt;/code&gt; (en Scala, Haskell)&lt;/strong&gt;? Normalmente este tipo de funciones tienen &lt;strong&gt;efectos colaterales&lt;/strong&gt;, pero si son &lt;strong&gt;puras&lt;/strong&gt; simplemente hacen corresponder elementos de un conjunto A a un &lt;strong&gt;Conjunto Unitario&lt;/strong&gt;. Es decir, todos los elementos en un conjunto A irán a parar al mismo valor. Ejemplos:
&lt;/p&gt;
&lt;div class=&#34;src src-haskell&#34;&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-haskell&#34; data-lang=&#34;haskell&#34;&gt;&lt;span class=&#34;nf&#34;&gt;fInt&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;::&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;Integer&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;nf&#34;&gt;fInt&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
En Haskell &lt;code class=&#34;verbatim&#34;&gt;_&lt;/code&gt; significa que da igual el argumento que le pases a la función &lt;code class=&#34;verbatim&#34;&gt;f&lt;/code&gt;, ya que lo va a ignorar, puedes definir la función anterior de forma más genérica:
&lt;/p&gt;
&lt;div class=&#34;src src-haskell&#34;&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-haskell&#34; data-lang=&#34;haskell&#34;&gt;&lt;span class=&#34;nf&#34;&gt;unit&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;::&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;nf&#34;&gt;unit&lt;/span&gt; &lt;span class=&#34;kr&#34;&gt;_&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
No importa qué tipo de argumento le pases a &lt;code class=&#34;verbatim&#34;&gt;unit&lt;/code&gt;, siempre va a hacer corresponder ese argumento a &lt;code class=&#34;verbatim&#34;&gt;Unit&lt;/code&gt;. Este es el equivalente en Scala:
&lt;/p&gt;
&lt;div class=&#34;src src-scala&#34;&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-scala&#34; data-lang=&#34;scala&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;unit&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;](&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;Unit&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
El siguiente paso lógico en los tipos es el &lt;strong&gt;conjunto de dos elementos,&lt;/strong&gt; que corresponde con &lt;code class=&#34;verbatim&#34;&gt;bool&lt;/code&gt; en C++, &lt;code class=&#34;verbatim&#34;&gt;Bool&lt;/code&gt; en Haskell y &lt;code class=&#34;verbatim&#34;&gt;Boolean&lt;/code&gt; en Scala. Las funciones a booleanos se llaman predicados, seguro que estás familiarizado con nombre como &lt;code class=&#34;verbatim&#34;&gt;isDigit, isLower, isLetter&lt;/code&gt; etc.
&lt;/p&gt;
&lt;h2 id=&#34;headline-6&#34;&gt;
Ejercicios
&lt;/h2&gt;
&lt;p&gt;
Quiero compartir contigo algunos de los ejercicios que he resuelto de los que propone Bartosz. Ten en cuenta que puedo estar equivocado, si detectas un error, o crees que algo puede mejorarse, &lt;strong&gt;deja un comentario&lt;/strong&gt;.
Puedes ver la lista de ejercicios completa en el blog de Bartosz (Enlazado en las referencias), yo solo he resuelto el 1 y el 6.
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;
Ejercicio 1
&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
Esta es mi solución. Intenté hacerlo con un &lt;code class=&#34;verbatim&#34;&gt;Map&lt;/code&gt; inmutable, pero no supe hacerlo funcionar:
&lt;/p&gt;
&lt;div class=&#34;src src-scala&#34;&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-scala&#34; data-lang=&#34;scala&#34;&gt;&lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Memoize&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;A&lt;/span&gt;, &lt;span class=&#34;kt&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;](&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;A&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;val&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;values&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;mutable.Map&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;A&lt;/span&gt;,&lt;span class=&#34;kt&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mutable&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;Map&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;empty&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;apply&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;values&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;getOrElseUpdate&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;))&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
Puedes probarlo con esta función:
&lt;/p&gt;
&lt;div class=&#34;src src-scala&#34;&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-scala&#34; data-lang=&#34;scala&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;Int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;nc&#34;&gt;Thread&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sleep&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;5000&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;val&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Memoize&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// Takes 5 secs
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;//&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;immediate&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;
Ejercicio 6
&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
&amp;lt;figure&amp;gt;
        &amp;lt;a href=&amp;#34;/img/teoria-categorias-scala-tipos-funciones.png&amp;#34;&amp;gt;
          &amp;lt;img
            on=&amp;#34;tap:lightbox1&amp;#34;
            role=&amp;#34;button&amp;#34;
            tabindex=&amp;#34;0&amp;#34;
            layout=&amp;#34;responsive&amp;#34;
            src=&amp;#34;/img/teoria-categorias-scala-tipos-funciones.png&amp;#34;
            alt=&amp;#34;Scala Category Theory functions and types&amp;#34;
            title=&amp;#34;Scala Category Theory functions and types&amp;#34;
            sizes=&amp;#34;(min-width: 640px) 640px, 100vw&amp;#34;
            width=&amp;#34;640&amp;#34;
            height=&amp;#34;527&amp;#34;&amp;gt;
          &amp;lt;/img&amp;gt;
        &amp;lt;/a&amp;gt;
&amp;lt;/figure&amp;gt;
&lt;/p&gt;
&lt;h2 id=&#34;headline-7&#34;&gt;
Referencias
&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://bartoszmilewski.com/2014/11/24/types-and-functions/trackback/&#34;&gt;Types and Functions, by Bartosz Milewski&lt;/a&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        
        <item>
            <title>Teoría de Categorías en Scala - Composición</title>
            <link>https://elbauldelprogramador.com/teoria-categorias-scala-composicion/</link>
            <pubDate>Tue, 24 Oct 2017 18:51:32 +0200</pubDate>
            
            <guid>https://elbauldelprogramador.com/teoria-categorias-scala-composicion/</guid>
            <description>&lt;p&gt;

&lt;blockquote&gt;
&lt;p&gt;Este artículo forma parte de una serie sobre Teoría de Categorías en Scala que estoy escribiendo basándome en &lt;a target=&#34;_blank&#34; href=&#34;https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/&#34;&gt;el libro de Bartosz Milewski&lt;/a&gt;. Conforme voy leyendo, tomo notas y intento resolver los ejercicios propuestos por Bartosz, pero en Scala. El producto de ese trabajo son estos artículos que comparto en este blog. Todo el código está en &lt;a href=&#34;https://github.com/elbaulp/Scala-Category-Theory&#34;&gt;elbaulp/Scala-Category-Theory&lt;/a&gt;, también puedes visitar la &lt;a href=&#34;https://elbauldelprogramador.com/scala-category-theory/&#34;&gt;tabla de contenidos&lt;/a&gt; de esta serie.&lt;/p&gt;
&lt;/blockquote&gt;



&lt;/p&gt;
&lt;h2 id=&#34;headline-1&#34;&gt;
CHANGELOG
&lt;/h2&gt;
&lt;p&gt;
&lt;em&gt;Gracias a Jesús López por comentar en este artículo y corregir unos cuantos errores.&lt;/em&gt;
&lt;/p&gt;
&lt;h2 id=&#34;headline-2&#34;&gt;
Introducción
&lt;/h2&gt;
&lt;p&gt;
Este es el primer artículo de una serie que voy a escribir sobre &lt;strong&gt;teoría de categorías&lt;/strong&gt;.
&lt;/p&gt;
&lt;p&gt;
Llevaba un tiempo queriendo aprender &lt;strong&gt;teoría de categorías&lt;/strong&gt;, ya que he leido bastante sobre el tema y parece que tiene &lt;a href=&#34;http://blog.ploeh.dk/2017/10/04/from-design-patterns-to-category-theory/&#34;&gt;aplicaciones en el desarrollo de software&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;
Esta serie de artículos se basan en gran libro que &lt;strong&gt;Bartosz Milewski&lt;/strong&gt; escribió hace un tiempo. Para aportar mi granito de arena, he decidido implementar los ejercicios que propone usando &lt;a href=&#34;https://elbauldelprogramador.com/tags/scala/&#34;&gt;scala&lt;/a&gt; y &lt;em&gt;tests basados en propiedades&lt;/em&gt; con &lt;code class=&#34;verbatim&#34;&gt;scalacheck&lt;/code&gt;. Espero que te guste esta serie, y no dudes en comentar tu opinión o sugerir/corregir el contenido.
&lt;/p&gt;
&lt;p&gt;
&amp;lt;!–ad–&amp;gt;
&lt;/p&gt;
&lt;h2 id=&#34;headline-3&#34;&gt;
Categoría: La esencia de la composición
&lt;/h2&gt;
&lt;p&gt;
Antes de continuar, ¿Qué es una &lt;em&gt;categoría?&lt;/em&gt;, de &lt;a href=&#34;https://es.wikipedia.org/wiki/Categor%C3%ADa_(matem%C3%A1ticas)&#34;&gt;Wikipedia&lt;/a&gt;:
&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;
En teoría de categorías, una categoría es una estructura algebraica que consta de una &lt;strong&gt;colección de objetos&lt;/strong&gt;, &lt;strong&gt;conectados unos con otros mediante flechas&lt;/strong&gt; tales que se cumplen las siguientes propiedades básicas: las flechas se pueden componer unas con otras de manera &lt;strong&gt;asociativa&lt;/strong&gt;, y para cada objeto existe una flecha que se comporta como un &lt;strong&gt;elemento neutro bajo la composición&lt;/strong&gt;.
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;
En resumen, una &lt;em&gt;categoría&lt;/em&gt; está formada por &lt;strong&gt;objetos y flechas&lt;/strong&gt;, y pueden componerse. Esto se aprecia mejor con una imagen:
&lt;/p&gt;
&lt;p&gt;
&amp;lt;figure&amp;gt;
        &amp;lt;a href=&amp;#34;/img/category-theory-composition.jpg&amp;#34;&amp;gt;
          &amp;lt;img
            on=&amp;#34;tap:lightbox1&amp;#34;
            role=&amp;#34;button&amp;#34;
            tabindex=&amp;#34;0&amp;#34;
            layout=&amp;#34;responsive&amp;#34;
            src=&amp;#34;/img/category-theory-composition.jpg&amp;#34;
            alt=&amp;#34;Arrows and objects category Theory&amp;#34;
            title=&amp;#34;Arrows and objects category Theory&amp;#34;
            sizes=&amp;#34;(min-width: 640px) 640px, 100vw&amp;#34;
            width=&amp;#34;640&amp;#34;
            height=&amp;#34;360&amp;#34;&amp;gt;
          &amp;lt;/img&amp;gt;
        &amp;lt;/a&amp;gt;
        &amp;lt;figcaption&amp;gt;Ejemplo de Categoría&amp;lt;/figcaption&amp;gt;
&amp;lt;/figure&amp;gt;
&lt;/p&gt;
&lt;p&gt;
Cada flecha puede &lt;strong&gt;componerse&lt;/strong&gt;, p.e: Si &lt;code class=&#34;verbatim&#34;&gt;A -&amp;gt; B&lt;/code&gt; y &lt;code class=&#34;verbatim&#34;&gt;B -&amp;gt; D&lt;/code&gt; entonces debe existir una flecha de &lt;code class=&#34;verbatim&#34;&gt;A -&amp;gt; D&lt;/code&gt;. Las flechas pueden llamarse &lt;strong&gt;morfismos&lt;/strong&gt;, y se pueden componer. En la imagen de arriba tienes:
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;
&lt;code class=&#34;verbatim&#34;&gt;f: A -&amp;gt; B&lt;/code&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;code class=&#34;verbatim&#34;&gt;g: B -&amp;gt; D&lt;/code&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
Si componemos esas dos, también tienes &lt;code class=&#34;verbatim&#34;&gt;h: A -&amp;gt; D&lt;/code&gt;.
&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
La composición se lee de &lt;em&gt;derecha a izquierda&lt;/em&gt;, por tanto &lt;code class=&#34;verbatim&#34;&gt;g∘f&lt;/code&gt; quiere decir &lt;code class=&#34;verbatim&#34;&gt;g(f(x))&lt;/code&gt;.
&lt;/p&gt;
&lt;h2 id=&#34;headline-4&#34;&gt;
Propiedades de la composición
&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;
&lt;strong&gt;Asociatividad:&lt;/strong&gt; &lt;code&gt;f∘(g∘h) == (f∘g)∘h == f∘g∘h&lt;/code&gt;.
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
Para cada objeto existe una &lt;strong&gt;flecha Identidad, o morfismo Identidad&lt;/strong&gt;, que va del objeto a sí mismo: &lt;code&gt;f∘IDₐ = f == IDₐ∘f = f&lt;/code&gt;, como muestro debajo:
&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;
&amp;lt;figure&amp;gt;
        &amp;lt;a href=&amp;#34;/img/category-theory-identity.jpg&amp;#34;&amp;gt;
          &amp;lt;img
            on=&amp;#34;tap:lightbox1&amp;#34;
            role=&amp;#34;button&amp;#34;
            tabindex=&amp;#34;0&amp;#34;
            layout=&amp;#34;responsive&amp;#34;
            src=&amp;#34;/img/category-theory-identity.jpg&amp;#34;
            alt=&amp;#34;Category Theory, object identity&amp;#34;
            title=&amp;#34;Category Theory, object identity&amp;#34;
            sizes=&amp;#34;(min-width: 640px) 640px, 100vw&amp;#34;
            width=&amp;#34;640&amp;#34;
            height=&amp;#34;360&amp;#34;&amp;gt;
          &amp;lt;/img&amp;gt;
        &amp;lt;/a&amp;gt;
&amp;lt;/figure&amp;gt;
&lt;/p&gt;
&lt;h2 id=&#34;headline-5&#34;&gt;
Ejemplos en Scala
&lt;/h2&gt;
&lt;p&gt;
Ahora que ya he comentado un poco de la teoría, vamos a implementarlo en &lt;strong&gt;scala&lt;/strong&gt;. Como dije al principio, voy a usar &lt;em&gt;tests basados en propiedades&lt;/em&gt; para comprobar que el objeto creado cumple las &lt;strong&gt;propiedades algebraicas&lt;/strong&gt; de una categoría. Estas propiedades son la &lt;strong&gt;Identidad&lt;/strong&gt; y &lt;strong&gt;asociatividad&lt;/strong&gt;.
&lt;/p&gt;
&lt;p&gt;
El código de abajo es la definición de una &lt;em&gt;categoría&lt;/em&gt; (Para ser más precisos, es una instancia de la categoría &lt;strong&gt;Hask&lt;/strong&gt;). En la categoría &lt;strong&gt;Hask&lt;/strong&gt;, los objetos son tipos y las flechas funciones. Puedes consultar el código en el fichero &lt;a href=&#34;https://github.com/elbaulp/Scala-Category-Theory/blob/master/src/main/scala/elbaulp/Category.scala&#34;&gt;Category.scala de mi respositorio.&lt;/a&gt;
&lt;/p&gt;
&lt;div class=&#34;src src-scala&#34;&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-scala&#34; data-lang=&#34;scala&#34;&gt;&lt;span class=&#34;k&#34;&gt;object&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Category&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Id&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;](&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;compose&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;A&lt;/span&gt;, &lt;span class=&#34;kt&#34;&gt;B&lt;/span&gt;, &lt;span class=&#34;kt&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;](&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;A&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;B&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;A&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;C&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;=&lt;/span&gt;
     &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;andThen&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;g&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
Es bastante simple, una función &lt;em&gt;identidad&lt;/em&gt; y otra función que &lt;em&gt;compone&lt;/em&gt; dos funciones. Para comprobar que cumple las propiedades, he escrito los siguientes tests.
&lt;/p&gt;
&lt;h2 id=&#34;headline-6&#34;&gt;
Tests basados en propiedades
&lt;/h2&gt;
&lt;p&gt;
Para mantener el artículo limpio, muestro solo el código necesario, puedes consultar el &lt;a href=&#34;https://github.com/elbaulp/Scala-Category-Theory/blob/master/src/test/scala/elbaulp/CategorySpec.scala&#34;&gt;código completo de los tests en github.&lt;/a&gt;
&lt;/p&gt;
&lt;h3 id=&#34;headline-7&#34;&gt;
Propiedad Identidad
&lt;/h3&gt;
&lt;div class=&#34;src src-scala&#34;&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-scala&#34; data-lang=&#34;scala&#34;&gt;&lt;span class=&#34;n&#34;&gt;property&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;a == Id(a)&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;check&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;forAll&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&amp;gt;&lt;/span&gt;
    &lt;span class=&#34;nc&#34;&gt;Category&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;Id&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;===&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;
  &lt;span class=&#34;o&#34;&gt;})&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;property&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Id∘f = f&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;check&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;forAll&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;Int&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&amp;gt;&lt;/span&gt;
    &lt;span class=&#34;nc&#34;&gt;Category&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;Id&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;square&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;===&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;square&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
  &lt;span class=&#34;o&#34;&gt;})&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;property&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;f∘Id = f&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;check&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;forAll&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;Int&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&amp;gt;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;Category&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;Id&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;===&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
  &lt;span class=&#34;o&#34;&gt;})&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
La primera propiedad manifiesta que para todo &lt;code class=&#34;verbatim&#34;&gt;String&lt;/code&gt; posible que se le pase a la función &lt;code class=&#34;verbatim&#34;&gt;identity&lt;/code&gt;, la &lt;code class=&#34;verbatim&#34;&gt;identidad&lt;/code&gt; siempre será la cadena de texto que se le pasó a la función.
&lt;/p&gt;
&lt;p&gt;
La segunda y tercera propiedad indican que no importa cómo se componga la función &lt;code class=&#34;verbatim&#34;&gt;identidad&lt;/code&gt; con otra función &lt;code class=&#34;verbatim&#34;&gt;f&lt;/code&gt;, ya que el resultado siempre será esa función &lt;code class=&#34;verbatim&#34;&gt;f&lt;/code&gt;.
&lt;/p&gt;
&lt;h3 id=&#34;headline-8&#34;&gt;
Propiedad asociativa
&lt;/h3&gt;
&lt;div class=&#34;src src-scala&#34;&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-scala&#34; data-lang=&#34;scala&#34;&gt;&lt;span class=&#34;n&#34;&gt;property&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Associativity: h∘(g∘f) = (h∘g)∘f = h∘g∘f&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;){&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;check&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;forAll&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;Int&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&amp;gt;&lt;/span&gt;
    &lt;span class=&#34;nc&#34;&gt;Category&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;compose&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;Category&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;compose&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;===&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Category&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;compose&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Category&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;compose&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;))(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
  &lt;span class=&#34;o&#34;&gt;})&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
Como puedes ver, este test comprueba que la propiedad asociativa es cierta.
&lt;/p&gt;
&lt;p&gt;
Si ejecutas estos tests, verás que todos pasan:
&lt;/p&gt;
&lt;p&gt;
&amp;lt;figure&amp;gt;
        &amp;lt;a href=&amp;#34;/img/category-theory-composition-test.png&amp;#34;&amp;gt;
          &amp;lt;img
            on=&amp;#34;tap:lightbox1&amp;#34;
            role=&amp;#34;button&amp;#34;
            tabindex=&amp;#34;0&amp;#34;
            layout=&amp;#34;responsive&amp;#34;
            src=&amp;#34;/img/category-theory-composition-test.png&amp;#34;
            alt=&amp;#34;Category theory property tests&amp;#34;
            title=&amp;#34;Category theory property tests&amp;#34;
            sizes=&amp;#34;(min-width: 397px) 397px, 100vw&amp;#34;
            width=&amp;#34;397&amp;#34;
            height=&amp;#34;105&amp;#34;&amp;gt;
          &amp;lt;/img&amp;gt;
        &amp;lt;/a&amp;gt;
&amp;lt;/figure&amp;gt;
&lt;/p&gt;
&lt;p&gt;
Eso es todo para esta primera parte, espero que te haya gustado. Me gustaría saber tu opinión, &lt;em&gt;te animo a comentar abajo&lt;/em&gt;.
&lt;/p&gt;
&lt;h2 id=&#34;headline-9&#34;&gt;
Recursos
&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://bartoszmilewski.com/2014/11/04/category-the-essence-of-composition/trackback/&#34;&gt;Category: The Essence of Composition&lt;/a&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        
    </channel>
</rss>
