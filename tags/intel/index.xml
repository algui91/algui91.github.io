<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Intel on El Baúl del programador</title>
        <link>https://elbauldelprogramador.com/tags/intel/</link>
        <description>Recent content in Intel on El Baúl del programador</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>es-ES</language>
        <lastBuildDate>Sat, 20 Aug 2016 05:06:16 +0000</lastBuildDate>
        <image>
            <url>https://elbauldelprogramador.com/img/bio-photo-rss.png</url>
            <link>https://elbauldelprogramador.com/tags/intel/</link>
            <title>Intel on El Baúl del programador</title>
            <width>144</width>
            <height>144</height>
        </image>
        <atom:link href="https://elbauldelprogramador.com/tags/intel/" rel="self" type="application/rss+xml" />
        
        <item>
            <title>Intel Anuncia Sus Nuevos Discos Duros, 1000 Veces Más Rápidos Que Los SSDs</title>
            <link>https://elbauldelprogramador.com/optanetm-3d-nand-tecnologa-3d-xpoint-intel-ssds/</link>
            <pubDate>Sat, 20 Aug 2016 05:06:16 +0000</pubDate>
            
            <guid>https://elbauldelprogramador.com/optanetm-3d-nand-tecnologa-3d-xpoint-intel-ssds/</guid>
            <description>&lt;blockquote&gt;
&lt;p&gt;En un artículo anterior hablamos de &lt;a href=&#34;https://elbauldelprogramador.com/intel-buffer-overflow-control-flow-enforcement-technology-cet/&#34; title=&#34;Cómo Intel Va a Acabar Con Los Buffers Overflows Con Control-Flow Enforcement&#34;&gt;Cómo Intel Va a Acabar Con Los Buffers Overflows Con Control-Flow Enforcement&lt;/a&gt;. Hoy Intel vuelve a ser noticia, hace unos días en el episodio #573 de &lt;a href=&#34;https://elbauldelprogramador.com/categories/security-now/&#34; title=&#34;Todos los artículos de Security Now!&#34;&gt;Security now!&lt;/a&gt; Steve habló de una nueva tecnología que ha creado Intel junto con Micron. Se llama &lt;strong&gt;3D XPoint&lt;/strong&gt; y con ella han creado dos tipos de discos duros 1000 veces más rápidos que los SSDs.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;A continuación se proporciona un resumen:&lt;/p&gt;
&lt;h1 id=&#34;características-de-la-nueva-memoria-3d-xpoint&#34;&gt;Características de la nueva memoria 3D XPoint™&lt;/h1&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;1000&lt;/strong&gt; veces &lt;strong&gt;más rápida&lt;/strong&gt; que las NANDs. La latencia de las NANDs se mide en decenas de &lt;strong&gt;microsegundos&lt;/strong&gt;, 3D Point en decenas de &lt;strong&gt;nanosegundos&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;1000 veces más resistencia&lt;/strong&gt; que las NANDs.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;10 veces más densa&lt;/strong&gt; que las memorias convencionales.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;No volátil&lt;/strong&gt;, Memoria no volátil (&lt;em&gt;NVM&lt;/em&gt;) es la nueva era de las memorias en los ordenadores, manteniendo los datos incluso después de que el ordenador se apague. Ejemplos de memorias no volátiles: 3D NAND, SSDs, y la tecnología 3D XPoint™.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;3d-xpoint-solventa-la-poca-durabilidad-de-los-ssds&#34;&gt;3D XPoint solventa la poca durabilidad de los SSDs&lt;/h1&gt;
&lt;p&gt;Con esta tecnología, que Intel pretende sacar al mercado &lt;strong&gt;en 2016&lt;/strong&gt;, se acaba con un gran problema que tienen los SSDs, su poca durabilidad. Los 3D XPoint acabarán por reemplazar a los SSDs en poco tiempo.&lt;/p&gt;
&lt;p&gt;El problema con los SSDs (Que son memoria NAND), es que se van varando electrones en una pequeña isla que está flotando con el aislante debajo. La forma de escribir en un SSD es crear un campo electroestático lo suficientemente potenten como para superar al aislante y que los electrones fluyan a través de él.&lt;/p&gt;
&lt;p&gt;Este proceso crea una fatiga en las propiedades físicas del aislante. Esta es la razón por la que escribir en dispositivos de memoria flash es costoso y causa daños a la larga. Algo que los discos duros convencionales no sufren. Esta nueva tecnología de &lt;a href=&#34;https://elbauldelprogramador.com/tags/intel&#34;&gt;Intel&lt;/a&gt;, &lt;strong&gt;3D XPoint&lt;/strong&gt; no sufre de este problema. Además es &lt;strong&gt;10 veces más denso&lt;/strong&gt; que la &lt;strong&gt;DRAM&lt;/strong&gt;.&lt;/p&gt;
&lt;h1 id=&#34;static-ram-sram-o-ram-estática&#34;&gt;Static RAM (SRAM) o RAM estática&lt;/h1&gt;
&lt;p&gt;La memoria RAM estática o &lt;em&gt;SRAM&lt;/em&gt; es como los &lt;a href=&#34;https://elbauldelprogramador.com/introduccion-los-procesos/&#34;&gt;registros del procesador&lt;/a&gt;, las &lt;em&gt;SRAM&lt;/em&gt; son inversores de acoplamiento cruzado. El problema que tiene este tipo de memoria es que requiere de muchos transistores, y éstos requieren de espacio físico y energía. También producen calor. Sin embargo son bastante rápidas. Como desventaja es que son volátiles, en cuanto no se les suministra energía los datos que almacenan se pierden.&lt;/p&gt;
&lt;h1 id=&#34;dynamic-ram-dram-o-ram-dinámica&#34;&gt;Dynamic RAM (DRAM) o RAM dinámica&lt;/h1&gt;
&lt;p&gt;Como mejora a la &lt;em&gt;SRAM&lt;/em&gt; se creó la &lt;em&gt;DRAM&lt;/em&gt;, que reducía la complejidad de la &lt;em&gt;SRAM&lt;/em&gt; a un solo transistor y un condensador. &lt;em&gt;DRAM&lt;/em&gt; almacena la información en el condensador. El problema de estos condensadores es que tienen que ser diminutos para poder colocarlos en un espacio pequeño. La desventaja de &lt;em&gt;DRAM&lt;/em&gt; es que hay que refrescar los condensadores periódicamente para que no pierdan la información almacenada, y hay que hacerlo con la suficiente frecuencia para no darle tiempo al condensador a que se descargue. También es volátil.&lt;/p&gt;
&lt;h1 id=&#34;memorias-3d-xpoint&#34;&gt;Memorias 3D XPoint&lt;/h1&gt;
&lt;p&gt;Estas nuevas memorias usan una tecnología de cambio de fase. Imaginemos un conjunto de conductores dispuestos horizontalmente, colocamos pequeños puntos de cosas en dichos conductores horizontalmente. Después, en la parte superior colocamos una rejilla de conductores verticalmente de forma que intersequen con los conductores horizontales en el punto X, de ahí el nombre &lt;strong&gt;XPoint&lt;/strong&gt;. La siguiente imagen ayuda a visualizarlo:&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;En cada intersección hay una sustancia que las separa. Lo que han conseguido es hacer pasar corriente a través de esta sustancia que cambia su resistencia permanentemente. Por lo tanto, si se envia un pulso de corriente en una dirección, su resistencia decáe. Por contra, al enviar la corriente en el sentido contrario, la resistencia aumenta. Esto se conoce como &lt;em&gt;bulk change&lt;/em&gt; (&lt;em&gt;Cambio en masa, o cambio masivo&lt;/em&gt;) y significa que el material al completo cambia su propiedad. Además es muy estable y &lt;strong&gt;no-volátil&lt;/strong&gt;.&lt;/p&gt;
&lt;h1 id=&#34;de-donde-viene-el-nombre-3d&#34;&gt;De donde viene el nombre 3D&lt;/h1&gt;
&lt;p&gt;Después de la descripción dada, uno puede imaginar de dónde sale el nombre &lt;strong&gt;3D&lt;/strong&gt;. Lo que hemos descrito es solo una capa, pero si vamos poniendo capas una encima de otra, apilándolas de forma que se aumenta la eficiencia enormemente.&lt;/p&gt;
&lt;h1 id=&#34;bulk-storage-almacenamiento-en-masa&#34;&gt;Bulk storage (Almacenamiento en masa)&lt;/h1&gt;
&lt;p&gt;Hasta ahora, los dispositivos de almacenamiento a los que estamos acostumbrados formaban una pirámide jerárquica. Siendo los discos duros los más lentos, pero con más capacidad, hasta la memoria caché del microprocesador (L1, L2 etc), la más rápida pero con menor capacidad. Esta tecnología se situa justo debajo de la &lt;em&gt;DRAM&lt;/em&gt;, como mostramos en la siguiente imagen:&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h1 id=&#34;propiedades-de-3d-xpoint&#34;&gt;Propiedades de 3D XPoint&lt;/h1&gt;
&lt;p&gt;Lo más impresionante de esta nueva tecnología es que es de &lt;strong&gt;acceso aleatorio&lt;/strong&gt;, de &lt;strong&gt;alta densidad&lt;/strong&gt; y &lt;strong&gt;no volátil&lt;/strong&gt;. Lo cual significa que tendremos velocidades similares a &lt;strong&gt;DRAM&lt;/strong&gt; pero sin perder la información al apagar el PC.&lt;/p&gt;
&lt;h1 id=&#34;conclusión&#34;&gt;Conclusión&lt;/h1&gt;
&lt;p&gt;Con esta nueva tecnología, en unos meses no tendremos que decir &lt;em&gt;“Me he comprado un PC con 8GB de RAM”&lt;/em&gt;, simplemente diremos  &lt;em&gt;“Me he comprado un ordenador con 20TB de almacenamiento &lt;strong&gt;XPoint&lt;/strong&gt;”&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;De aquí a unos 5/10 años, seguramente los SSDs &lt;strong&gt;Optane&lt;/strong&gt; de Intel hayan reemplazado a los &lt;strong&gt;SSDs&lt;/strong&gt; de hoy día.&lt;/p&gt;
&lt;p&gt;¿Qué te ha parecido esta nueva tecnología? Déjanos un comentario con tu opinión.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h1 id=&#34;referencias&#34;&gt;Referencias&lt;/h1&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;ul&gt;
&lt;li&gt;3D XPoint™ Unveiled—The Next Breakthrough in Memory Technology. &lt;a href=&#34;http://www.intel.com/content/www/us/en/architecture-and-technology/3d-xpoint-unveiled-video.html&#34; title=&#34;3D XPoint™ Unveiled—The Next Breakthrough in Memory Technology&#34;&gt;intel.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Introducing Breakthrough Memory Technology. &lt;a href=&#34;http://www.intel.com/content/www/us/en/architecture-and-technology/non-volatile-memory.html&#34; title=&#34;Introducing Breakthrough Memory Technology&#34;&gt;intel.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        
        <item>
            <title>Cómo Intel Va a Acabar Con Los Buffers Overflows Con Control-Flow Enforcement Technology (CET)</title>
            <link>https://elbauldelprogramador.com/intel-buffer-overflow-control-flow-enforcement-technology-cet/</link>
            <pubDate>Tue, 05 Jul 2016 20:09:47 +0000</pubDate>
            
            <guid>https://elbauldelprogramador.com/intel-buffer-overflow-control-flow-enforcement-technology-cet/</guid>
            <description>&lt;p&gt;Hace tiempo que hablamos aquí sobre lo que es un &lt;a href=&#34;https://elbauldelprogramador.com/explotacion-buffers-overflows-y-exploits-parte-i/&#34; title=&#34;Explotación – Buffers OverFlows y exploits&#34;&gt;Buffer Overflow&lt;/a&gt; y cómo aprovecharnos de ellos para tomar control del sistema. Pues bien, Intel se propone acabar con este tipo tan común de vulnerabilidad en sus nuevos procesadores.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Este artículo está basado en el episodio #565 de Security Now!, &lt;em&gt;Control-Flow Enforcement Technology (CET)&lt;/em&gt;, puedes ver todos los artículos traducidos en la página &lt;a href=&#34;https://elbauldelprogramador.com/security-now/&#34; title=&#34;Página de episodios traducidos&#34;&gt;security now!&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h1 id=&#34;cómo-pretende-intel-acabar-con-los-buffers-overflows&#34;&gt;Cómo pretende Intel acabar con los buffers overflows&lt;/h1&gt;
&lt;p&gt;Básicamente Intel añadirá una nueva instrucción a sus procesadores, llamada &lt;strong&gt;ENDBRANCH&lt;/strong&gt; y una nueva funcionalidad llamada &lt;strong&gt;Shadow stack&lt;/strong&gt;, que podría traducirse como pila oculta. Antes de meternos de lleno a describir ambas novedades, analicemos el problema.&lt;/p&gt;
&lt;h1 id=&#34;un-poco-de-historia&#34;&gt;Un poco de historia&lt;/h1&gt;
&lt;p&gt;El problema con la programación orientada al retorno (&lt;em&gt;return oriented-programming&lt;/em&gt;) es que la gente inteligente ideó una forma de conseguir ejecutar código que ya tenía privilegios de ejecución. A lo largo de los años se ha producido una batalla entre gente intentando explotar programas y las compañías intentando idear métodos que lo impidieran.&lt;/p&gt;
&lt;p&gt;La primera medida de prevención fue el bit &lt;strong&gt;NX&lt;/strong&gt; (&lt;em&gt;No-eXecute bit&lt;/em&gt;), este bit se añadió a los sistemas para evitar los problemas mencionados en el párrafo anterior, que consistía en proporcionar datos al sistema y conseguir que esos datos se ejecutaran. Es decir, en estos sistemas no se diferenciaba lo que era código para ejecutar y lo que eran los datos, por lo que si conseguías que el procesador ejecutara unos datos cuidadosamente proporcionados&amp;hellip; te hacías con el sistema. En la arquitectura Von Neuman clásica, los datos e instrucciones comparten el mismo espacio.&lt;/p&gt;
&lt;h2 id=&#34;instrucción-nx&#34;&gt;Instrucción NX&lt;/h2&gt;
&lt;p&gt;Como hemos mencionado, esta compartición de espacio entre datos e instrucciones tenía el siguiente problema: Si consigues que el procesador ejecute una instrucción de salto (&lt;em&gt;jump&lt;/em&gt; ) a esa zona de datos que contiene intencionadamente instrucciones, el procesador las ejecutará. En orden de prevenir este tipo de ataques se creó la el bit &lt;strong&gt;NX&lt;/strong&gt;, una bandera o flag que se añadió al hardware que especifica qué región de memoria no puede ejecutarse. De esta forma, si alguien introduce datos y mediante una instrucción &lt;em&gt;jmp&lt;/em&gt; salta a ellos, el procesador no ejecutará las intrucciones en esos datos porque están marcados con el flag &lt;strong&gt;NX&lt;/strong&gt;. Pero como siempre, la gente es muy lista.&lt;/p&gt;
&lt;h2 id=&#34;cómo-saltarse-la-protección-del-bit-nx&#34;&gt;Cómo saltarse la protección del bit NX&lt;/h2&gt;
&lt;p&gt;Ya que esta protección estaba activada, los hackers idearon otra forma de saltarsela, intentar desactivar el bit saltando a alguna región de memoria que sea de ejecución y tenga la llamada al sistema que desactiva el bit &lt;strong&gt;NX&lt;/strong&gt;, normalmente saltaban a una subrutina del kernel, y sobre-escribían la dirección de retorno para saltar a la parte donde reside el código que ellos quieren ejecutar. De este modo ya volvían a poder ejecutar lo que quisieran en la región de datos. ¿Cual fue la contramedida de Intel en ese entonces?  &lt;em&gt;ASLR&lt;/em&gt; (&lt;em&gt;Address Space Layout Randomization&lt;/em&gt;)&lt;/p&gt;
&lt;h2 id=&#34;qué-es-aslr-address-space-layout-randomization&#34;&gt;Qué es ASLR (Address Space Layout Randomization)&lt;/h2&gt;
&lt;p&gt;Para prevenir los ataques del tipo anterior, Intel ideo otra solución, aleatorizar la distribución del espacio en el que se reparte el código ejecutable del sistema operativo. Sin embargo, debido al diseño de la arquitectura, no tenían mucho espacio de donde aleatorizar, normalmente disponían solo de 8 bits, es decir 256 posibles localizaciones en memoria. 256 opciones no son muchas, así que los malos podían simplemente probar suerte, fallarían 255 de cada 256 veces, pero acertarían 1 de cada 256, una baja probabilidad de acierto, pero mejor que 0.&lt;/p&gt;
&lt;h3 id=&#34;mi-ordenador-se-ha-quedado-colgado-por-alguna-misteriosa-razón&#34;&gt;Mi ordenador se ha quedado colgado por alguna misteriosa razón&amp;hellip;&lt;/h3&gt;
&lt;p&gt;Seguro que alguna vez os ha pasado, el ordenador se queda colgado, os aparece una pantallazo azul&amp;hellip; y simplemente habéis reiniciado y todo parece estar correcto, pues bien, esto fruto de alguien probando suerte en vuestro sistema, y fallando una de esas 255 veces que puede equivocarse “probando suerte” intentando hacerse con vuestro PC.&lt;/p&gt;
&lt;h1 id=&#34;la-nueva-instrucción-endbranch-de-intel&#34;&gt;La nueva instrucción ENDBRANCH de Intel&lt;/h1&gt;
&lt;p&gt;Despues de este pequeño repaso por la historia de las vulnerabilidades, vamos a describir la nueva instrucción que Intel ha creado para acabar con los &lt;em&gt;Buffers Overflows&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Su funcionamiento es simple, &lt;strong&gt;ENDBRANCH&lt;/strong&gt; es el único destino válido de una instrucción &lt;code&gt;call&lt;/code&gt; o &lt;code&gt;jump&lt;/code&gt;. Es decir, el principio de cada subrutina debe empezar con la instrucción &lt;strong&gt;ENDBRANCH&lt;/strong&gt;. Lo elegante de este diseño, es que los procesadores tienen un &lt;a href=&#34;https://en.wikipedia.org/wiki/Instruction_pipelining&#34;&gt;Instruction Pipeline&lt;/a&gt;, y conforme el procesador va leyendo instrucciones que tiene que ejecutar y encuentra una instrucción &lt;code&gt;call&lt;/code&gt; o &lt;code&gt;jump&lt;/code&gt; (Recuerda que estas intrucciones tiene que aterrizar en un &lt;strong&gt;ENDBRANCH&lt;/strong&gt;), la instrucción inmediatamente siguiente que va a coger el pipeline debe ser un &lt;strong&gt;ENDBRANCH&lt;/strong&gt;. Por tanto, como esto debe de ser inmutable, Intel sabe que tras una instrucción &lt;code&gt;call&lt;/code&gt; o &lt;code&gt;jump&lt;/code&gt; la siguiente debe ser &lt;strong&gt;ENDBRANCH&lt;/strong&gt;, así que Intel ha añadido un pequeño autómata finito que comprueba que esto es cierto, de no ser así, lanza una excepción y aborta el proceso.&lt;/p&gt;
&lt;p&gt;Con esta simple mejora, se acaba el problema de sobre-escribir la dirección de retorno de una función para permitir al atacante saltar a una porción de codigo que él controla. Al obligar a que la instrucción &lt;strong&gt;ENDBRANCH&lt;/strong&gt; sea la primera instrucción de todas las subrutinas, define un único punto de entrada válido. Cualquier intento de saltar a la mitad o al final de una función es imposible, ya que el proceso se abortará.&lt;/p&gt;
&lt;h1 id=&#34;la-pila-stack-y-la-nueva-funcionalidad-de-intel-shadow-stack&#34;&gt;La pila (Stack) y la nueva funcionalidad de Intel, Shadow Stack&lt;/h1&gt;
&lt;p&gt;Todos estamos familiarizados con el concepto de &lt;a href=&#34;https://es.wikipedia.org/wiki/Pila_(inform%C3%A1tica)&#34; title=&#34;Definición de Pila&#34;&gt;Pila (Stack)&lt;/a&gt; esa estructura de datos que permite introducir datos y sacar datos. Cuando se inventó en su día, de repente permitía hacer llamadas recursivas, lo cual hasta el momento no podía hacerse. Pero el problema con la pila viene a ser el mismo de antes, se comparten instrucciones y datos. Cuando se llama a un método, con unos parámetros, se introduce en la pila la dirección de retorno y los parámetros de la función, si los tuviera. He aquí el problema, es un claro objetivo para un ataque &lt;em&gt;buffer overflow&lt;/em&gt;. En la pila se reserva un espacio para variables de tamaño variable (Valga la redundancia), si no se usa correctamente y no se hacen comprobaciones del tamaño de lo que se intenta guardar en una variable, se corre el riesgo de que alguien mal intencionado desborde la capacidad de esa variable y consiga sobre-escribir la dirección de retorno de la pila. Ya sabemos qué puede pasar cuando alguien sobr escribe la dirección de retorno, pueden saltar a donde quiera y tomar el control.&lt;/p&gt;
&lt;p&gt;Para resolver este problema Intel ha diseñado la llamada &lt;em&gt;Shadow Stack&lt;/em&gt; o pila oculta. Es una pila a la que el desarrollador no tiene acceso, y mantiene una copia de los parámetros de la pila normal, como dirección de retorno etc, pero nada de datos. Cuando el programador modifica la pila, lo hace en la normal, a la que tiene acceso. Y aquí reside la fortaleza del &lt;em&gt;Shadow Stack&lt;/em&gt;, al no tener acceso, cuando el sistema mira la dirección de retorno, si esta dirección no coincide en ambas pilas, alguien ha modificado la dirección de retorno en la pila normal y el proceso se aborta. Y así, Intel ha puesto fin a años de vulnerabilidades debidas al simple hecho de no comprobar que el tamaño de los datos que intentamos guardar en una variable, no cabe en el espacio que tienen reservado. Una obra maestra.&lt;/p&gt;
&lt;p&gt;Además, no implica ningun decremento en el rendimiento del sistema, ya que está implementado en hardware, es problema de Intel añadir los transictores necesarios a sus procesadores para que esto funcione.&lt;/p&gt;
&lt;h1 id=&#34;conclusión&#34;&gt;Conclusión&lt;/h1&gt;
&lt;p&gt;Me ha parecido un tema muy interesante y quería compartirlo con vosotros, espero que también os haya gustado. Dejanos un comentario para hacernos llegar tu opinión!&lt;/p&gt;
&lt;h1 id=&#34;referencias&#34;&gt;Referencias&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Security Now 565 Control-Flow Enforcement Technology (CET) | &lt;a href=&#34;https://twit.tv/shows/security-now/episodes/565&#34; title=&#34;Security Now 565
Control-Flow Enforcement Technology (CET)&#34;&gt;twit.tv&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Episodio en Youtube | &lt;a href=&#34;https://www.youtube.com/watch?v=W3AdFoJ8lCs&#34; title=&#34;Security Now 565
Control-Flow Enforcement Technology (CET)&#34;&gt;Youtube.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        
    </channel>
</rss>
